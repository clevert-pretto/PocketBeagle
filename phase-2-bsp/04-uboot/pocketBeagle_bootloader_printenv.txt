U-Boot 2022.04-g5509547b (Jan 22 2026 - 19:56:08 +0000)

CPU  : AM335X-GP rev 2.1
Model: TI AM335x PocketBeagle
DRAM:  512 MiB
Reset Source: Power-on reset has occurred.
RTC 32KCLK Source: Internal.
Core:  146 devices, 12 uclasses, devicetree: separate
WDT:   Started wdt@44e35000 with servicing (60s timeout)
MMC:   OMAP SD/MMC: 0
Loading Environment from EXT4...
** Unable to use mmc 0:1 for loading the env **
Model: BeagleBoard.org PocketBeagle
<ethaddr> not set. Validating first E-fuse MAC
Net:   No ethernet found.
Press SPACE to abort autoboot in 0 seconds
=> printenv
arch=arm
args_mmc=run finduuid;setenv bootargs console=${console} ${cape_uboot} root=PART                            UUID=${uuid} ro rootfstype=${mmcrootfstype} ${uboot_detected_capes} ${cmdline}
args_mmc_old=setenv bootargs console=${console} ${optargs} ${cape_uboot} root=${                            oldroot} ro rootfstype=${mmcrootfstype} ${uboot_detected_capes} ${cmdline}
args_mmc_uuid=setenv bootargs console=${console} ${optargs} ${cape_uboot} root=U                            UID=${uuid} ro rootfstype=${mmcrootfstype} ${uboot_detected_capes} ${cmdline}
args_netinstall=setenv bootargs ${netinstall_bootargs} ${optargs} ${cape_uboot}                             root=/dev/ram rw ${uboot_detected_capes} ${cmdline}
args_uenv_root=setenv bootargs console=${console} ${optargs} ${cape_uboot} root=                            ${uenv_root} ro rootfstype=${mmcrootfstype} ${uboot_detected_capes} ${cmdline}
baudrate=115200
board=am335x
board_eeprom_header=undefined
board_name=A335PBGL
board_rev=00A2
board_serial=1750EPB00044
boot=${devtype} dev ${mmcdev}; if ${devtype} rescan; then gpio set 54;setenv boo                            tpart ${mmcdev}:1; if test -e ${devtype} ${bootpart} /etc/fstab; then setenv mmc                            part 1;fi; echo Checking for: /uEnv.txt ...;if test -e ${devtype} ${bootpart} /u                            Env.txt; then if run loadbootenv; then gpio set 55;echo Loaded environment from                             /uEnv.txt;run importbootenv;fi;echo Checking if uenvcmd is set ...;if test -n ${                            uenvcmd}; then gpio set 56;echo Running uenvcmd ...;run uenvcmd;fi;fi; echo Chec                            king for: /boot/uEnv.txt ...;for i in 1 2 3 4 5 6 7 ; do setenv mmcpart ${i};set                            env bootpart ${mmcdev}:${mmcpart};if test -e ${devtype} ${bootpart} /boot/uEnv.t                            xt; then gpio set 55;load ${devtype} ${bootpart} ${loadaddr} /boot/uEnv.txt;env                             import -t ${loadaddr} ${filesize};echo Loaded environment from /boot/uEnv.txt;if                             test -n ${dtb}; then echo debug: [dtb=${dtb}] ... ;setenv fdtfile ${dtb};echo U                            sing: dtb=${fdtfile} ...;fi;echo Checking if uname_r is set in /boot/uEnv.txt...                            ;if test -n ${uname_r}; then gpio set 56; setenv oldroot /dev/mmcblk${mmcdev}p${                            mmcpart};echo Running uname_boot ...;run uname_boot;fi;fi;done;fi;
boot_a_script=load ${devtype} ${devnum}:${distro_bootpart} ${scriptaddr} ${prefi                            x}${script}; source ${scriptaddr}
boot_efi_binary=load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_r} ef                            i/boot/bootarm.efi; if fdt addr ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${f                            dt_addr_r};else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi
boot_efi_bootmgr=if fdt addr ${fdt_addr_r}; then bootefi bootmgr ${fdt_addr_r};e                            lse bootefi bootmgr;fi
boot_extlinux=sysboot ${devtype} ${devnum}:${distro_bootpart} any ${scriptaddr}                             ${prefix}${boot_syslinux_conf}
boot_fdt=try
boot_net_usb_start=usb start
boot_prefixes=/ /boot/
boot_script_dhcp=boot.scr.uimg
boot_scripts=boot.scr.uimg boot.scr
boot_syslinux_conf=extlinux/extlinux.conf
boot_targets=mmc0 legacy_mmc0 mmc1 legacy_mmc1 usb0 pxe dhcp
bootcmd=run findfdt; run init_console; run envboot; run distro_bootcmd
bootcmd_dhcp=devtype=dhcp; run boot_net_usb_start; if dhcp ${scriptaddr} ${boot_                            script_dhcp}; then source ${scriptaddr}; fi;setenv efi_fdtfile ${fdtfile}; if te                            st -z "${fdtfile}" -a -n "${soc}"; then setenv efi_fdtfile ${soc}-${board}${boar                            dver}.dtb; fi; setenv efi_old_vci ${bootp_vci};setenv efi_old_arch ${bootp_arch}                            ;setenv bootp_vci PXEClient:Arch:00010:UNDI:003000;setenv bootp_arch 0xa;if dhcp                             ${kernel_addr_r}; then tftpboot ${fdt_addr_r} dtb/${efi_fdtfile};if fdt addr ${                            fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r}; else bootefi ${kernel_                            addr_r} ${fdtcontroladdr};fi;fi;setenv bootp_vci ${efi_old_vci};setenv bootp_arc                            h ${efi_old_arch};setenv efi_fdtfile;setenv efi_old_arch;setenv efi_old_vci;
bootcmd_legacy_mmc0=gpio clear 56; gpio clear 55; gpio clear 54; gpio set 53; se                            tenv devtype mmc; setenv mmcdev 0; setenv bootpart 0:1 ; run boot
bootcmd_legacy_mmc1=gpio clear 56; gpio clear 55; gpio clear 54; gpio set 53; se                            tenv devtype mmc; setenv mmcdev 1; setenv bootpart 1:1 ; run boot
bootcmd_mmc0=devnum=0; run mmc_boot
bootcmd_mmc1=devnum=1; run mmc_boot
bootcmd_pxe=run boot_net_usb_start; dhcp; if pxe get; then pxe boot; fi
bootcmd_usb0=devnum=0; run usb_boot
bootcount=1
bootdelay=0
bootdir=/boot
bootenv=uEnv.txt
bootenvfile=uEnv.txt
bootfile=zImage
bootm_size=0x10000000
bootpart=0:2
bootscript=echo Running bootscript from mmc${bootpart} ...; source ${loadaddr}
console=ttyS0,115200n8
cpu=armv7
dfu_alt_info_emmc=rawemmc raw 0 3751936;boot part 1 1;rootfs part 1 2;MLO fat 1                             1;MLO.raw raw 0x100 0x200;u-boot.img.raw raw 0x300 0x1000;u-env.raw raw 0x1300 0                            x200;spl-os-args.raw raw 0x1500 0x200;spl-os-image.raw raw 0x1700 0x6900;spl-os-                            args fat 1 1;spl-os-image fat 1 1;u-boot.img fat 1 1;uEnv.txt fat 1 1
dfu_alt_info_mmc=boot part 0 1;rootfs part 0 2;MLO fat 0 1;MLO.raw raw 0x100 0x2                            00;u-boot.img.raw raw 0x300 0x1000;u-env.raw raw 0x1300 0x200;spl-os-args.raw ra                            w 0x1500 0x200;spl-os-image.raw raw 0x1700 0x6900;spl-os-args fat 0 1;spl-os-ima                            ge fat 0 1;u-boot.img fat 0 1;uEnv.txt fat 0 1
dfu_alt_info_ram=kernel ram 0x80200000 0x4000000;fdt ram 0x80f80000 0x80000;ramd                            isk ram 0x81000000 0x4000000
distro_bootcmd=for target in ${boot_targets}; do run bootcmd_${target}; done
dtboaddr=0x89000000
eeprom_bbb_header=i2c dev 0; i2c mw 0x50 0x00.2 aa; i2c mw 0x50 0x01.2 55; i2c m                            w 0x50 0x02.2 33; i2c mw 0x50 0x03.2 ee; i2c mw 0x50 0x04.2 41; i2c mw 0x50 0x05                            .2 33; i2c mw 0x50 0x06.2 33; i2c mw 0x50 0x07.2 35; i2c mw 0x50 0x08.2 42; i2c                             mw 0x50 0x09.2 4e; i2c mw 0x50 0x0a.2 4c; i2c mw 0x50 0x0b.2 54;
eeprom_bbbl_footer= i2c mw 0x50 0x0c.2 42; i2c mw 0x50 0x0d.2 4c; i2c mw 0x50 0x                            0e.2 41; i2c mw 0x50 0x0f.2 32;
eeprom_bbbw_footer= i2c mw 0x50 0x0c.2 42; i2c mw 0x50 0x0d.2 57; i2c mw 0x50 0x                            0e.2 41; i2c mw 0x50 0x0f.2 35;
eeprom_bbgg_footer= i2c mw 0x50 0x0c.2 47; i2c mw 0x50 0x0d.2 47; i2c mw 0x50 0x                            0e.2 31; i2c mw 0x50 0x0f.2 41;
eeprom_beaglelogic= i2c mw 0x50 0x00.2 aa; i2c mw 0x50 0x01.2 55; i2c mw 0x50 0x                            02.2 33; i2c mw 0x50 0x03.2 ee; i2c mw 0x50 0x04.2 41; i2c mw 0x50 0x05.2 33; i2                            c mw 0x50 0x06.2 33; i2c mw 0x50 0x07.2 35; i2c mw 0x50 0x08.2 42; i2c mw 0x50 0                            x09.2 4c; i2c mw 0x50 0x0a.2 47; i2c mw 0x50 0x0b.2 43; i2c mw 0x50 0x0c.2 30; i                            2c mw 0x50 0x0d.2 30; i2c mw 0x50 0x0e.2 30; i2c mw 0x50 0x0f.2 41;
eeprom_blank=i2c dev 0; i2c mw 0x50 0x00.2 ff; i2c mw 0x50 0x01.2 ff; i2c mw 0x5                            0 0x02.2 ff; i2c mw 0x50 0x03.2 ff; i2c mw 0x50 0x04.2 ff; i2c mw 0x50 0x05.2 ff                            ; i2c mw 0x50 0x06.2 ff; i2c mw 0x50 0x07.2 ff; i2c mw 0x50 0x08.2 ff; i2c mw 0x                            50 0x09.2 ff; i2c mw 0x50 0x0a.2 ff; i2c mw 0x50 0x0b.2 ff; i2c mw 0x50 0x0c.2 f                            f; i2c mw 0x50 0x0d.2 ff; i2c mw 0x50 0x0e.2 ff; i2c mw 0x50 0x0f.2 ff; i2c mw 0                            x50 0x10.2 ff; i2c mw 0x50 0x11.2 ff; i2c mw 0x50 0x12.2 ff; i2c mw 0x50 0x13.2                             ff; i2c mw 0x50 0x14.2 ff; i2c mw 0x50 0x15.2 ff; i2c mw 0x50 0x16.2 ff; i2c mw                             0x50 0x17.2 ff; i2c mw 0x50 0x18.2 ff; i2c mw 0x50 0x19.2 ff; i2c mw 0x50 0x1a.2                             ff; i2c mw 0x50 0x1b.2 ff; i2c mw 0x50 0x1c.2 ff; i2c mw 0x50 0x1d.2 ff; i2c mw                             0x50 0x1e.2 ff; i2c mw 0x50 0x1f.2 ff;
eeprom_dump=i2c dev 0; i2c md 0x50 0x00.2 20;
eeprom_pocketbeagle= i2c mw 0x50 0x00.2 aa; i2c mw 0x50 0x01.2 55; i2c mw 0x50 0                            x02.2 33; i2c mw 0x50 0x03.2 ee; i2c mw 0x50 0x04.2 41; i2c mw 0x50 0x05.2 33; i                            2c mw 0x50 0x06.2 33; i2c mw 0x50 0x07.2 35; i2c mw 0x50 0x08.2 50; i2c mw 0x50                             0x09.2 42; i2c mw 0x50 0x0a.2 47; i2c mw 0x50 0x0b.2 4c; i2c mw 0x50 0x0c.2 30;                             i2c mw 0x50 0x0d.2 30; i2c mw 0x50 0x0e.2 41; i2c mw 0x50 0x0f.2 32;
eeprom_program=if test $board_eeprom_header = bbb_blank; then run eeprom_dump; r                            un eeprom_blank; run eeprom_bbb_header; run eeprom_dump; reset; fi; if test $boa                            rd_eeprom_header = bbbl_blank; then run eeprom_dump; run eeprom_blank; run eepro                            m_bbb_header; run eeprom_bbbl_footer; run eeprom_dump; reset; fi; if test $board                            _eeprom_header = bbbw_blank; then run eeprom_dump; run eeprom_blank; run eeprom_                            bbb_header; run eeprom_bbbw_footer; run eeprom_dump; reset; fi; if test $board_e                            eprom_header = pocketbeagle_blank; then run eeprom_dump; run eeprom_blank; run e                            eprom_pocketbeagle; run eeprom_dump; reset; fi; if test $board_eeprom_header = b                            bgg_blank; then run eeprom_dump; run eeprom_blank; run eeprom_bbb_header; run ee                            prom_bbgg_footer; run eeprom_dump; reset; fi; if test $board_eeprom_header = bea                            glelogic_blank; then run eeprom_dump; run eeprom_blank; run eeprom_beaglelogic;                             run eeprom_dump; reset; fi;
efi_dtb_prefixes=/ /dtb/ /dtb/current/
envboot=mmc dev ${mmcdev}; if mmc rescan; then echo SD/MMC found on device ${mmc                            dev};if run loadbootscript; then run bootscript;else if run loadbootenv; then ec                            ho Loaded env from ${bootenvfile};run importbootenv;fi;if test -n $uenvcmd; then                             echo Running uenvcmd ...;run uenvcmd;fi;fi;fi;
eth1addr=98:5d:ad:30:16:27
ethaddr=98:5d:ad:30:16:25
fdt_addr_r=0x88000000
fdtaddr=0x88000000
fdtcontroladdr=9df338b0
fdtfile=undefined
fdtoverlay_addr_r=0x89000000
findfdt=echo board_name=[$board_name] ...; if test $board_name = A335BLNK; then                             echo EEPROM IS BLANK!!! ...; echo Assuming am335x-bonegreen compatible ...; sete                            nv fdtfile am335x-bonegreen.dtb; fi; if test $board_name = A335BLGC; then setenv                             fdtfile am335x-beaglelogic.dtb; fi; if test $board_name = A335BONE; then setenv                             fdtfile am335x-bone.dtb; fi; if test $board_name = A335BNLT; then echo board_re                            v=[$board_rev] ...; if test $board_rev = GH01; then setenv fdtfile am335x-bonebl                            ack.dtb; elif test $board_rev = BBG1; then setenv fdtfile am335x-bonegreen.dtb;                             elif test $board_rev = BP00; then setenv fdtfile am335x-pocketbone.dtb; elif tes                            t $board_rev = GW1A; then setenv fdtfile am335x-bonegreen-wireless.dtb; elif tes                            t $board_rev = GG1A; then setenv fdtfile am335x-bonegreen-gateway.dtb; elif test                             $board_rev = AIA0; then setenv fdtfile am335x-abbbi.dtb; elif test $board_rev =                             EIA0; then setenv fdtfile am335x-boneblack.dtb; elif test $board_rev = ME06; th                            en setenv fdtfile am335x-bonegreen.dtb; elif test $board_rev = OS00; then setenv                             fdtfile am335x-osd3358-sm-red.dtb; elif test $board_rev = OS01; then setenv fdt                            file am335x-osd3358-sm-red-v4.dtb; elif test $board_rev = 00D0; then setenv fdtf                            ile am335x-boneblack-revd.dtb; elif test $board_rev = EID0; then setenv fdtfile                             am335x-boneblack-revd.dtb; else setenv fdtfile am335x-boneblack.dtb; fi; fi; if                             test $board_name = A335PBGL; then setenv fdtfile am335x-pocketbeagle.dtb; fi; if                             test $board_name = BBBW; then setenv fdtfile am335x-boneblack-wireless.dtb; fi;                             if test $board_name = BBG1; then setenv fdtfile am335x-bonegreen.dtb; fi; if te                            st $board_name = BBGW; then setenv fdtfile am335x-bonegreen-wireless.dtb; fi; if                             test $board_name = BBGG; then setenv fdtfile am335x-bonegreen-gateway.dtb; fi;                             if test $board_name = BBGE; then setenv fdtfile am335x-bonegreen-eco.dtb; fi; if                             test $board_name = BBBL; then setenv fdtfile am335x-boneblue.dtb; fi; if test $                            board_name = BBEN; then setenv fdtfile am335x-sancloud-bbe.dtb; fi; if test $boa                            rd_name = BBELITE; then setenv fdtfile am335x-sancloud-bbe-lite.dtb; fi; if test                             $board_name = BBE_EX_WIFI; then setenv fdtfile am335x-sancloud-bbe-extended-wif                            i.dtb; fi; if test $board_name = OS00; then setenv fdtfile am335x-osd3358-sm-red                            .dtb; fi; if test $board_name = OS01; then setenv fdtfile am335x-osd3358-sm-red-                            v4.dtb; fi; if test $board_name = A33515BB; then setenv fdtfile am335x-evm.dtb;                             fi; if test $board_name = A335X_SK; then setenv fdtfile am335x-evmsk.dtb; fi; if                             test $board_name = A335_ICE; then setenv fdtfile am335x-icev2.dtb; if test $ice                            _mii = mii; then setenv pxe_label_override Pruss; fi;fi; if test $fdtfile = unde                            fined; then echo WARNING: Defaulting to am335x-bonegreen; setenv board_name A335                            BNLT; setenv board_rev EMMC; setenv fdtfile am335x-bonegreen.dtb; fi;
finduuid=part uuid ${devtype} ${bootpart} uuid
ice_mii=mii
importbootenv=echo Importing environment from ${devtype} ...; env import -t ${lo                            adaddr} ${filesize}
init_console=if test $board_name = A335_ICE; then setenv console ttyS3,115200n8;                            elif test $board_name = A335BLGC; then setenv console ttyS4,115200n8;else setenv                             console ttyS0,115200n8;fi;
kernel_addr_r=0x82000000
load_efi_dtb=load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix                            }${efi_fdtfile}
loadaddr=0x82000000
loadbootenv=load ${devtype} ${bootpart} ${loadaddr} ${bootenvfile}
loadbootscript=load ${devtype} ${bootpart} ${loadaddr} ${scriptfile};
loadfdt=echo loading ${fdtdir}/${fdtfile} ...; load ${devtype} ${bootpart} ${fdt                            addr} ${fdtdir}/${fdtfile}
loadimage=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}
loadoverlay=echo uboot_overlays: loading ${actual_uboot_overlay} ...; load ${dev                            type} ${bootpart} ${rdaddr} ${actual_uboot_overlay}; fdt addr ${fdtaddr}; fdt re                            size ${fdt_buffer}; fdt apply ${rdaddr}; fdt resize ${fdt_buffer};
loadramdisk=load mmc ${mmcdev} ${rdaddr} ramdisk.gz
loadrd=load ${devtype} ${bootpart} ${rdaddr} ${bootdir}/${rdfile}; setenv rdsize                             ${filesize}
mmc_boot=if mmc dev ${devnum}; then devtype=mmc; run scan_dev_for_boot_part; fi
mmcboot=mmc dev ${mmcdev}; devnum=${mmcdev}; devtype=mmc; if mmc rescan; then ec                            ho SD/MMC found on device ${mmcdev};if run loadimage; then run args_mmc; if test                             ${boot_fit} -eq 1; then run run_fit; else run mmcloados;fi;fi;fi;
mmcdev=0
mmcloados=if test ${boot_fdt} = yes || test ${boot_fdt} = try; then if run loadf                            dt; then if test -n ${uname_r}; then bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdt                            addr}; else bootz ${loadaddr} - ${fdtaddr}; fi; else if test ${boot_fdt} = try;                             then bootz; else echo WARN: Cannot load the DT; fi; fi; else bootz; fi;
mmcrootfstype=ext4 rootwait
netargs=setenv bootargs console=${console} ${optargs} root=/dev/nfs nfsroot=${se                            rverip}:${rootpath},${nfsopts} rw ip=dhcp
netboot=echo Booting from network ...; setenv autoload no; dhcp; run netloadimag                            e; run netloadfdt; run netargs; bootz ${loadaddr} - ${fdtaddr}
netloadfdt=tftp ${fdtaddr} ${fdtfile}
netloadimage=tftp ${loadaddr} ${bootfile}
nfsopts=nolock
partitions=uuid_disk=${uuid_gpt_disk};name=bootloader,start=384K,size=1792K,uuid                            =${uuid_gpt_bootloader};name=rootfs,start=2688K,size=-,uuid=${uuid_gpt_rootfs}
pxefile_addr_r=0x80100000
ramargs=setenv bootargs console=${console} ${optargs} root=${ramroot} rootfstype                            =${ramrootfstype}
ramboot=echo Booting from ramdisk ...; run ramargs; bootz ${loadaddr} ${rdaddr}                             ${fdtaddr}
ramdisk_addr_r=0x88080000
ramroot=/dev/ram0 rw
ramrootfstype=ext2
rdaddr=0x88080000
rootpath=/export/rootfs
scan_dev_for_boot=echo Scanning ${devtype} ${devnum}:${distro_bootpart}...; for                             prefix in ${boot_prefixes}; do run scan_dev_for_extlinux; run scan_dev_for_scrip                            ts; done;run scan_dev_for_efi;
scan_dev_for_boot_part=part list ${devtype} ${devnum} -bootable devplist; env ex                            ists devplist || setenv devplist 1; for distro_bootpart in ${devplist}; do if fs                            type ${devtype} ${devnum}:${distro_bootpart} bootfstype; then run scan_dev_for_b                            oot; fi; done; setenv devplist
scan_dev_for_efi=setenv efi_fdtfile ${fdtfile}; if test -z "${fdtfile}" -a -n "$                            {soc}"; then setenv efi_fdtfile ${soc}-${board}${boardver}.dtb; fi; for prefix i                            n ${efi_dtb_prefixes}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${p                            refix}${efi_fdtfile}; then run load_efi_dtb; fi;done;run boot_efi_bootmgr;if tes                            t -e ${devtype} ${devnum}:${distro_bootpart} efi/boot/bootarm.efi; then echo Fou                            nd EFI removable media binary efi/boot/bootarm.efi; run boot_efi_binary; echo EF                            I LOAD FAILED: continuing...; fi; setenv efi_fdtfile
scan_dev_for_extlinux=if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefi                            x}${boot_syslinux_conf}; then echo Found ${prefix}${boot_syslinux_conf}; run boo                            t_extlinux; echo SCRIPT FAILED: continuing...; fi
scan_dev_for_scripts=for script in ${boot_scripts}; do if test -e ${devtype} ${d                            evnum}:${distro_bootpart} ${prefix}${script}; then echo Found U-Boot script ${pr                            efix}${script}; run boot_a_script; echo SCRIPT FAILED: continuing...; fi; done
script=boot.scr
scriptaddr=0x80000000
scriptfile=${script}
serial#=1750EPB00044
soc=am33xx
spiargs=setenv bootargs console=${console} ${optargs} root=${spiroot} rootfstype                            =${spirootfstype}
spiboot=echo Booting from spi ...; run spiargs; sf probe ${spibusno}:0; sf read                             ${loadaddr} ${spisrcaddr} ${spiimgsize}; bootz ${loadaddr}
spibusno=0
spiimgsize=0x362000
spiroot=/dev/mtdblock4 rw
spirootfstype=jffs2
spisrcaddr=0xe0000
static_ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}::off
stderr=serial@0
stdin=serial@0
stdout=serial@0
uname_boot=setenv bootdir /boot; setenv bootfile vmlinuz-${uname_r}; if test -e                             ${devtype} ${bootpart} ${bootdir}/${bootfile}; then echo loading ${bootdir}/${bo                            otfile} ...; run loadimage;setenv fdtdir /boot/dtbs/${uname_r}; echo debug: [ena                            ble_uboot_overlays=${enable_uboot_overlays}] ... ;if test -n ${enable_uboot_over                            lays}; then echo debug: [enable_uboot_cape_universal=${enable_uboot_cape_univers                            al}] ... ;if test -n ${enable_uboot_cape_universal}; then echo debug: [uboot_bas                            e_dtb_univ=${uboot_base_dtb_univ}] ... ;if test -n ${uboot_base_dtb_univ}; then                             echo uboot_overlays: [uboot_base_dtb=${uboot_base_dtb_univ}] ... ;if test -e ${d                            evtype} ${bootpart} ${fdtdir}/${uboot_base_dtb_univ}; then setenv fdtfile ${uboo                            t_base_dtb_univ};echo uboot_overlays: Switching too: dtb=${fdtfile} ...;setenv c                            ape_uboot bone_capemgr.uboot_capemgr_enabled=1; else echo debug: unable to find                             [${uboot_base_dtb_univ}] using [${uboot_base_dtb}] instead ... ;echo debug: [ubo                            ot_base_dtb_univ=${uboot_base_dtb}] ... ;if test -n ${uboot_base_dtb}; then echo                             uboot_overlays: [uboot_base_dtb=${uboot_base_dtb}] ... ;if test -e ${devtype} $                            {bootpart} ${fdtdir}/${uboot_base_dtb}; then setenv fdtfile ${uboot_base_dtb};ec                            ho uboot_overlays: Switching too: dtb=${fdtfile} ...;fi;fi;fi;fi;else echo debug                            : [uboot_base_dtb_univ=${uboot_base_dtb}] ... ;if test -n ${uboot_base_dtb}; the                            n echo uboot_overlays: [uboot_base_dtb=${uboot_base_dtb}] ... ;if test -e ${devt                            ype} ${bootpart} ${fdtdir}/${uboot_base_dtb}; then setenv fdtfile ${uboot_base_d                            tb};echo uboot_overlays: Switching too: dtb=${fdtfile} ...;fi;fi;fi;fi;if test -                            e ${devtype} ${bootpart} ${fdtdir}/${fdtfile}; then run loadfdt;else setenv fdtd                            ir /usr/lib/linux-image-${uname_r}; if test -e ${devtype} ${bootpart} ${fdtdir}/                            ${fdtfile}; then run loadfdt;else setenv fdtdir /lib/firmware/${uname_r}/device-                            tree; if test -e ${devtype} ${bootpart} ${fdtdir}/${fdtfile}; then run loadfdt;e                            lse setenv fdtdir /boot/dtb-${uname_r}; if test -e ${devtype} ${bootpart} ${fdtd                            ir}/${fdtfile}; then run loadfdt;else setenv fdtdir /boot/dtbs; if test -e ${dev                            type} ${bootpart} ${fdtdir}/${fdtfile}; then run loadfdt;else setenv fdtdir /boo                            t/dtb; if test -e ${devtype} ${bootpart} ${fdtdir}/${fdtfile}; then run loadfdt;                            else setenv fdtdir /boot; if test -e ${devtype} ${bootpart} ${fdtdir}/${fdtfile}                            ; then run loadfdt;else if test -e ${devtype} ${bootpart} ${fdtfile}; then run l                            oadfdt;else echo; echo unable to find [dtb=${fdtfile}] did you name it correctly                            ? ...; run failumsboot;fi;fi;fi;fi;fi;fi;fi;fi; if test -n ${enable_uboot_overla                            ys}; then extension scan;setenv fdt_buffer 0x60000;if test -n ${uboot_fdt_buffer                            }; then setenv fdt_buffer ${uboot_fdt_buffer};fi;echo uboot_overlays: [fdt_buffe                            r=${fdt_buffer}] ... ;if test -n ${uboot_silicon}; then setenv uboot_overlay ${u                            boot_silicon}; run virtualloadoverlay;fi;if test -n ${uboot_model}; then setenv                             uboot_overlay ${uboot_model}; run virtualloadoverlay;fi;if test -n ${disable_ubo                            ot_overlay_adc}; then echo uboot_overlays: uboot loading of [BB-ADC-00A0.dtbo] d                            isabled by /boot/uEnv.txt [disable_uboot_overlay_adc=1]...;else setenv uboot_ove                            rlay BB-ADC-00A0.dtbo; run virtualloadoverlay;fi;if test -n ${uboot_overlay_addr                            0}; then if test -n ${disable_uboot_overlay_addr0}; then echo uboot_overlays: ub                            oot loading of [${uboot_overlay_addr0}] disabled by /boot/uEnv.txt [disable_uboo                            t_overlay_addr0=1]...;else setenv uboot_overlay ${uboot_overlay_addr0}; run virt                            ualloadoverlay;fi;fi;if test -n ${uboot_overlay_addr1}; then if test -n ${disabl                            e_uboot_overlay_addr1}; then echo uboot_overlays: uboot loading of [${uboot_over                            lay_addr1}] disabled by /boot/uEnv.txt [disable_uboot_overlay_addr1=1]...;else s                            etenv uboot_overlay ${uboot_overlay_addr1}; run virtualloadoverlay;fi;fi;if test                             -n ${uboot_overlay_addr2}; then if test -n ${disable_uboot_overlay_addr2}; then                             echo uboot_overlays: uboot loading of [${uboot_overlay_addr2}] disabled by /boo                            t/uEnv.txt [disable_uboot_overlay_addr2=1]...;else setenv uboot_overlay ${uboot_                            overlay_addr2}; run virtualloadoverlay;fi;fi;if test -n ${uboot_overlay_addr3};                             then if test -n ${disable_uboot_overlay_addr3}; then echo uboot_overlays: uboot                             loading of [${uboot_overlay_addr3}] disabled by /boot/uEnv.txt [disable_uboot_ov                            erlay_addr3=1]...;else setenv uboot_overlay ${uboot_overlay_addr3}; run virtuall                            oadoverlay;fi;fi;if test -n ${uboot_overlay_addr4}; then setenv uboot_overlay ${                            uboot_overlay_addr4}; run virtualloadoverlay;fi;if test -n ${uboot_overlay_addr5                            }; then setenv uboot_overlay ${uboot_overlay_addr5}; run virtualloadoverlay;fi;i                            f test -n ${uboot_overlay_addr6}; then setenv uboot_overlay ${uboot_overlay_addr                            6}; run virtualloadoverlay;fi;if test -n ${uboot_overlay_addr7}; then setenv ubo                            ot_overlay ${uboot_overlay_addr7}; run virtualloadoverlay;fi;if test -n ${uboot_                            emmc}; then if test -n ${disable_uboot_overlay_emmc}; then echo uboot_overlays:                             uboot loading of [${uboot_emmc}] disabled by /boot/uEnv.txt [disable_uboot_overl                            ay_emmc=1]...;else setenv uboot_overlay ${uboot_emmc}; run virtualloadoverlay;fi                            ;fi;if test -n ${uboot_video}; then if test -n ${disable_uboot_overlay_video}; t                            hen echo uboot_overlays: uboot loading of [${uboot_video}] disabled by /boot/uEn                            v.txt [disable_uboot_overlay_video=1]...;else if test -n ${disable_uboot_overlay                            _audio}; then echo uboot_overlays: uboot loading of [${uboot_video}] disabled by                             /boot/uEnv.txt [disable_uboot_overlay_audio=1]...;setenv uboot_overlay ${uboot_                            video_naudio}; run virtualloadoverlay;else setenv uboot_overlay ${uboot_video};                             run virtualloadoverlay;fi;fi;fi;if test -n ${uboot_wireless}; then if test -n ${                            disable_uboot_overlay_wireless}; then echo uboot_overlays: uboot loading of [${u                            boot_wireless}] disabled by /boot/uEnv.txt [disable_uboot_overlay_wireless=1]...                            ;else setenv uboot_overlay ${uboot_wireless}; run virtualloadoverlay;fi;fi;if te                            st -n ${uboot_overlay_pru}; then setenv uboot_overlay ${uboot_overlay_pru}; run                             virtualloadoverlay;fi;if test -n ${uboot_overlay_pru_add}; then setenv uboot_ove                            rlay ${uboot_overlay_pru_add}; run virtualloadoverlay;fi;if test -n ${dtb_overla                            y}; then setenv uboot_overlay ${dtb_overlay}; echo uboot_overlays: [dtb_overlay=                            ${uboot_overlay}] ... ;run virtualloadoverlay;fi;else echo uboot_overlays: add [                            enable_uboot_overlays=1] to /boot/uEnv.txt to enable...;fi;if test -n ${uboot_de                            tected_capes}; then echo uboot_overlays: [uboot_detected_capes=${uboot_detected_                            capes_addr0}${uboot_detected_capes_addr1}${uboot_detected_capes_addr2}${uboot_de                            tected_capes_addr3}] ... ;setenv uboot_detected_capes uboot_detected_capes=${ubo                            ot_detected_capes_addr0}${uboot_detected_capes_addr1}${uboot_detected_capes_addr                            2}${uboot_detected_capes_addr3}; fi;setenv rdfile initrd.img-${uname_r}; if test                             -e ${devtype} ${bootpart} ${bootdir}/${rdfile}; then echo loading ${bootdir}/${                            rdfile} ...; run loadrd;if test -n ${netinstall_enable}; then run args_netinstal                            l; run message;echo debug: [${bootargs}] ... ;echo debug: [bootz ${loadaddr} ${r                            daddr}:${rdsize} ${fdtaddr}] ... ;bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtadd                            r}; fi;if test -n ${uenv_root}; then run args_uenv_root;echo debug: [${bootargs}                            ] ... ;echo debug: [bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}] ... ;bootz                             ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}; fi;if test -n ${uuid}; then run arg                            s_mmc_uuid;echo debug: [${bootargs}] ... ;echo debug: [bootz ${loadaddr} ${rdadd                            r}:${rdsize} ${fdtaddr}] ... ;bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr};                             fi;run args_mmc_old;echo debug: [${bootargs}] ... ;echo debug: [bootz ${loadaddr                            } ${rdaddr}:${rdsize} ${fdtaddr}] ... ;bootz ${loadaddr} ${rdaddr}:${rdsize} ${f                            dtaddr}; else if test -n ${uenv_root}; then run args_uenv_root;echo debug: [${bo                            otargs}] ... ;echo debug: [bootz ${loadaddr} - ${fdtaddr}] ... ;bootz ${loadaddr                            } - ${fdtaddr}; fi;run args_mmc_old;echo debug: [${bootargs}] ... ;echo debug: [                            bootz ${loadaddr} - ${fdtaddr}] ... ;bootz ${loadaddr} - ${fdtaddr}; fi;fi;
usb_boot=usb start; if usb dev ${devnum}; then devtype=usb; run scan_dev_for_boo                            t_part; fi
vendor=ti
ver=U-Boot 2022.04-g5509547b (Jan 22 2026 - 19:56:08 +0000)
virtualloadoverlay=if test -e ${devtype} ${bootpart} ${fdtdir}/${uboot_overlay};                             then setenv actual_uboot_overlay ${fdtdir}/${uboot_overlay}; run loadoverlay;el                            se if test -e ${devtype} ${bootpart} ${fdtdir}/overlays/${uboot_overlay}; then s                            etenv actual_uboot_overlay ${fdtdir}/overlays/${uboot_overlay}; run loadoverlay;                            else if test -e ${devtype} ${bootpart} /lib/firmware/${uboot_overlay}; then sete                            nv actual_uboot_overlay /lib/firmware/${uboot_overlay}; run loadoverlay;else if                             test -e ${devtype} ${bootpart} ${uboot_overlay}; then setenv actual_uboot_overla                            y ${uboot_overlay}; run loadoverlay;else echo uboot_overlays: unable to find [${                            devtype} ${bootpart} ${uboot_overlay}]...;fi;fi;fi;fi;

Environment size: 24948/131068 bytes
